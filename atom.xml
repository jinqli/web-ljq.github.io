<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://web-ljq.github.io</id>
    <title>木子李</title>
    <updated>2021-04-11T04:22:08.694Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://web-ljq.github.io"/>
    <link rel="self" href="https://web-ljq.github.io/atom.xml"/>
    <subtitle>剑，最要远离的就是感情</subtitle>
    <logo>https://web-ljq.github.io/images/avatar.png</logo>
    <icon>https://web-ljq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 木子李</rights>
    <entry>
        <title type="html"><![CDATA[web安全学习路线总结-自学篇]]></title>
        <id>https://web-ljq.github.io/post/web-an-quan-xue-xi-lu-xian-zong-jie-zi-xue-pian/</id>
        <link href="https://web-ljq.github.io/post/web-an-quan-xue-xi-lu-xian-zong-jie-zi-xue-pian/">
        </link>
        <updated>2021-04-11T03:26:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习web安全（web渗透测试）之前，应该了解什么是web。</p>
</blockquote>
<hr>
<h2 id="细分">细分</h2>
<ol>
<li>web前端安全</li>
<li>web后端安全</li>
<li>web数据安全</li>
<li>web通信安全</li>
<li>web容器安全</li>
</ol>
<hr>
<ul>
<li>web前端，常指客户端浏览器，<br>
技术架构：HTML，CSS，JavaScript<br>
攻击方式：xss，csrf</li>
</ul>
<hr>
<ul>
<li>web后端，指的是放在服务端用来处理数据逻辑的代码<br>
可以是不同的编程语言实现：PHP，Python，Java，Go等语言</li>
</ul>
<hr>
<ul>
<li>web数据：指的是数据库的安全问题<br>
最常见的是Mysql，Oracle，Redis等数据库（昨晚拿学校官网测试了一下，发现学校官网用的是SQL Server，裂开。。。）</li>
</ul>
<hr>
<ul>
<li>web通信：有url劫持，和dns劫持等<br>
这一块需要掌握的是通信协议这些技术，比如http和https，tcp/ip那一家子</li>
</ul>
<hr>
<ul>
<li>web容器安全：针对一些存放web源代码的一个容器<br>
比如我自己用的Nginx，还有apache，Tomcat，以及没接触过的IIS（Internet Information Services）</li>
</ul>
<hr>
<h2 id="总结">总结</h2>
<p>所以说，学习web安全并不是一件轻松的事情，需要涉及到的知识确实比较多，但这些都阻挡不了我进去的决心😂</p>
<blockquote>
<p>第一次写，其中肯定会有所不足，待我技术提高之时再来更新此文。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS数组打平]]></title>
        <id>https://web-ljq.github.io/post/js-da-ping-shu-zu/</id>
        <link href="https://web-ljq.github.io/post/js-da-ping-shu-zu/">
        </link>
        <updated>2021-04-10T10:25:10.000Z</updated>
        <summary type="html"><![CDATA[<p>一次面试碰到的题，还记得当时一脸懵逼，果然还是代码敲少了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一次面试碰到的题，还记得当时一脸懵逼，果然还是代码敲少了。</p>
<!-- more -->
<p>如题：</p>
<pre><code class="language-javaScript">let initialArray = [1,2,3,4,[5,6,7],[8,9,[10,11]]];
let outputArray = [1,2,3,4,5,6,7,8,9,10,11];
</code></pre>
<hr>
<ul>
<li>第一种：数组自带的方法 Array.flat()</li>
</ul>
<pre><code class="language-javaScript">initialArray.flat(Infinity); // 展开无限层，也可以是Number，flat(1)
</code></pre>
<hr>
<ul>
<li>第二种：通过递归实现（明人不说暗话，我面试的时候也是用的递归，遍历初始数组里面的元素是不是单个元素，若是直接push，不是的话再来一遍</li>
</ul>
<pre><code class="language-javaScript">function myFlat(arr) {
    // 定义一个空数组用来放结果
    let emptyArray = [];
    arr.map(item =&gt; {
        // 进行条件判断是不是数组
        if(Array.isArray(item)){
            // 是的话就继续调用flat
            // flat返回的是数组形式，所以需要使用 concat
            emptyArray = emptyArray.concat(myFlat(item));
        } else {
            emptyArray.push(item); // 是单个元素，直接push
        };
    });
    return emptyArray; // 返回结果
};
</code></pre>
<hr>
<ul>
<li>第三种：(toString &amp;&amp; split) 或 (join &amp;&amp; split)</li>
</ul>
<pre><code class="language-javaScript">// 调用数组的toString方法和join方法，将数组变为字符串
// 然后再用split分割还原为数组

function myFlatten_3(initialArray) {
   return (
       initialArray
       // .toString()
       .join()
       .split(&quot;,&quot;)
       .map((item) =&gt; {
           // return item;
           // return Number(item);
           return parseInt(item);
       })
   );
}
console.log(myFlatten_3());
</code></pre>
<hr>
<ul>
<li>第四种：扩展运算符</li>
</ul>
<pre><code class="language-javaScript">// 利用es6的扩展运算符，对数组进行遍历，只要里面有数组就扩展直到没有为止
function myFlatten_4(initialArray) {
  while (initialArray.some((item) =&gt; Array.isArray(item))) {
    initialArray = [].concat(...initialArray);
  }
  return initialArray;
}
console.log(myFlatten_4());
</code></pre>
<hr>
<blockquote>
<p>以上几种是我目前能力能理解的方法了，数组打平肯定还有其他方法，继续加油。</p>
</blockquote>
]]></content>
    </entry>
</feed>